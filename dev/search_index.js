var documenterSearchIndex = {"docs":
[{"location":"pybraket/#PyBraket","page":"PyBraket","title":"PyBraket","text":"","category":"section"},{"location":"pybraket/","page":"PyBraket","title":"PyBraket","text":"","category":"page"},{"location":"results/#Results","page":"Results","title":"Results","text":"","category":"section"},{"location":"results/","page":"Results","title":"Results","text":"Braket.Result\nExpectation\nExpectation(::Any, ::Any)\nExpectation(::Circuit, ::Any, ::Any)\nVariance\nVariance(::Any, ::Any)\nVariance(::Circuit, ::Any, ::Any)\nSample\nSample(::Any, ::Any)\nSample(::Circuit, ::Any, ::Any)\nAmplitude\nAmplitude(::String)\nAmplitude(::Circuit, ::Any)\nProbability\nProbability(::Any)\nProbability(::Circuit, ::Any)\nDensityMatrix\nDensityMatrix(::Any)\nDensityMatrix(::Circuit, ::Any)\nStateVector\nStateVector(::Circuit)","category":"page"},{"location":"results/#Braket.Result","page":"Results","title":"Braket.Result","text":"Result\n\nAbstract type representing a measurement to perform on a Circuit.\n\nSee also: Expectation, Variance, Sample, Probability, DensityMatrix, and Amplitude.\n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.Expectation","page":"Results","title":"Braket.Expectation","text":"Expectation <: Result\n\nStruct which represents a expectation measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.Expectation-Tuple{Any, Any}","page":"Results","title":"Braket.Expectation","text":"Expectation(o, targets) -> Expectation\nExpectation(o) -> Expectation\n\nConstructs a Expectation of an observable o on qubits targets.\n\no may be one of:\n\nAny Observable\nA String corresponding to an Observable (e.g. \"x\"`)\nA Vector{String} in which each element corresponds to an Observable\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the observable o will be applied to all qubits provided it is a single qubit observable.\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Expectation-Tuple{Circuit, Any, Any}","page":"Results","title":"Braket.Expectation","text":"Expectation(c::Circuit, o, targets) -> Circuit\nExpectation(c::Circuit, o) -> Circuit\n\nConstructs a Expectation of an observable o on qubits targets and adds it as a result to Circuit c.\n\no may be one of:\n\nAny Observable\nA String corresponding to an Observable (e.g. \"x\")\nA Vector{String} in which each element corresponds to an Observable\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the observable o will be applied to all qubits provided it is a single qubit observable.\n\nExamples\n\njulia> c = Circuit();\n\njulia> c = H(c, collect(0:10));\n\njulia> c = Expectation(c, Braket.Observables.Z(), 0);\n\njulia> c = Expectation(c, Braket.Observables.X());\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Variance","page":"Results","title":"Braket.Variance","text":"Variance <: Result\n\nStruct which represents a variance measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.Variance-Tuple{Any, Any}","page":"Results","title":"Braket.Variance","text":"Variance(o, targets) -> Variance\nVariance(o) -> Variance\n\nConstructs a Variance of an observable o on qubits targets.\n\no may be one of:\n\nAny Observable\nA String corresponding to an Observable (e.g. \"x\"`)\nA Vector{String} in which each element corresponds to an Observable\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the observable o will be applied to all qubits provided it is a single qubit observable.\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Variance-Tuple{Circuit, Any, Any}","page":"Results","title":"Braket.Variance","text":"Variance(c::Circuit, o, targets) -> Circuit\nVariance(c::Circuit, o) -> Circuit\n\nConstructs a Variance of an observable o on qubits targets and adds it as a result to Circuit c.\n\no may be one of:\n\nAny Observable\nA String corresponding to an Observable (e.g. \"x\")\nA Vector{String} in which each element corresponds to an Observable\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the observable o will be applied to all qubits provided it is a single qubit observable.\n\nExamples\n\njulia> c = Circuit();\n\njulia> c = H(c, collect(0:10));\n\njulia> c = Variance(c, Braket.Observables.Z(), 0);\n\njulia> c = Variance(c, Braket.Observables.X());\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Sample","page":"Results","title":"Braket.Sample","text":"Sample <: Result\n\nStruct which represents a sample measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.Sample-Tuple{Any, Any}","page":"Results","title":"Braket.Sample","text":"Sample(o, targets) -> Sample\nSample(o) -> Sample\n\nConstructs a Sample of an observable o on qubits targets.\n\no may be one of:\n\nAny Observable\nA String corresponding to an Observable (e.g. \"x\"`)\nA Vector{String} in which each element corresponds to an Observable\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the observable o will be applied to all qubits provided it is a single qubit observable.\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Sample-Tuple{Circuit, Any, Any}","page":"Results","title":"Braket.Sample","text":"Sample(c::Circuit, o, targets) -> Circuit\nSample(c::Circuit, o) -> Circuit\n\nConstructs a Sample of an observable o on qubits targets and adds it as a result to Circuit c.\n\no may be one of:\n\nAny Observable\nA String corresponding to an Observable (e.g. \"x\")\nA Vector{String} in which each element corresponds to an Observable\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the observable o will be applied to all qubits provided it is a single qubit observable.\n\nExamples\n\njulia> c = Circuit();\n\njulia> c = H(c, collect(0:10));\n\njulia> c = Sample(c, Braket.Observables.Z(), 0);\n\njulia> c = Sample(c, Braket.Observables.X());\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Amplitude","page":"Results","title":"Braket.Amplitude","text":"Amplitude <: Result\n\nStruct which represents an amplitude measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.Amplitude-Tuple{String}","page":"Results","title":"Braket.Amplitude","text":"Amplitude(states) -> Amplitude\n\nConstructs an Amplitude measurement of states.\n\nstates may be one of:\n\nA Vector{String}\nA String\n\nAll elements of states must be '0' or '1'.\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Amplitude-Tuple{Circuit, Any}","page":"Results","title":"Braket.Amplitude","text":"Amplitude(c::Circuit, states) -> Circuit\n\nConstructs an Amplitude measurement of states and adds it as a result to Circuit c.\n\nstates may be of type:\n\nVector{String}\nString\n\nAll elements of states must be '0' or '1'.\n\nExamples\n\njulia> c = Circuit();\n\njulia> c = H(c, collect(0:3));\n\njulia> c = Amplitude(c, \"0000\");\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Probability","page":"Results","title":"Braket.Probability","text":"Probability <: Result\n\nStruct which represents a probability measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.Probability-Tuple{Any}","page":"Results","title":"Braket.Probability","text":"Probability(targets) -> Probability\nProbability() -> Probability\n\nConstructs a Probability on qubits targets.\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the measurement will be applied to all qubits.\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.Probability-Tuple{Circuit, Any}","page":"Results","title":"Braket.Probability","text":"Probability(c::Circuit, targets) -> Circuit\nProbability(c::Circuit) -> Circuit\n\nConstructs a Probability measurement on qubits targets and adds it as a result to Circuit c.\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the measurement will be applied to all qubits of c.\n\nExamples\n\njulia> c = Circuit();\n\njulia> c = H(c, collect(0:3));\n\njulia> c = Probability(c, 2);\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.DensityMatrix","page":"Results","title":"Braket.DensityMatrix","text":"DensityMatrix <: Result\n\nStruct which represents a densitymatrix measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.DensityMatrix-Tuple{Any}","page":"Results","title":"Braket.DensityMatrix","text":"DensityMatrix(targets) -> DensityMatrix\nDensityMatrix() -> DensityMatrix\n\nConstructs a DensityMatrix on qubits targets.\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the measurement will be applied to all qubits.\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.DensityMatrix-Tuple{Circuit, Any}","page":"Results","title":"Braket.DensityMatrix","text":"DensityMatrix(c::Circuit, targets) -> Circuit\n\nConstructs a DensityMatrix measurement on qubits targets and adds it as a result to Circuit c.\n\ntargets may be one of:\n\nA QubitSet\nA Vector of Ints and/or Qubits\nAn Int or Qubit\nAbsent, in which case the measurement will be applied to all qubits of c.\n\nExamples\n\njulia> c = Circuit();\n\njulia> c = H(c, collect(0:3));\n\njulia> c = DensityMatrix(c, 2);\n\n\n\n\n\n","category":"method"},{"location":"results/#Braket.StateVector","page":"Results","title":"Braket.StateVector","text":"StateVector <: Result\n\nStruct which represents a state vector measurement on a Circuit. \n\n\n\n\n\n","category":"type"},{"location":"results/#Braket.StateVector-Tuple{Circuit}","page":"Results","title":"Braket.StateVector","text":"StateVector(c::Circuit) -> Circuit\n\nConstructs a StateVector measurement on all qubits of c and adds it as a result to Circuit c.\n\nExamples\n\njulia> c = Circuit();\n\njulia> c = H(c, collect(0:3));\n\njulia> c = StateVector(c);\n\n\n\n\n\n","category":"method"},{"location":"tasks/#Tasks","page":"Tasks","title":"Tasks","text":"","category":"section"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"\"Tasks\" are units of work that run on AWS managed devices, such as managed simulators and QPUs. See the Braket documentation about how tasks work and submitting tasks for more information.","category":"page"},{"location":"tasks/","page":"Tasks","title":"Tasks","text":"AwsQuantumTask\nAwsQuantumTask(::String, ::Union{Braket.AbstractProgram, Circuit, AnalogHamiltonianSimulation})\nAwsQuantumTaskBatch\nAwsQuantumTaskBatch(::String, ::Vector{<:Union{Braket.AbstractProgram, Circuit}})\nresults(::AwsQuantumTaskBatch)","category":"page"},{"location":"tasks/#Braket.AwsQuantumTask","page":"Tasks","title":"Braket.AwsQuantumTask","text":"AwsQuantumTask\n\nStruct representing a task run on an Amazon-managed device.\n\n\n\n\n\n","category":"type"},{"location":"tasks/#Braket.AwsQuantumTask-Tuple{String, Union{Braket.AbstractProgram, AnalogHamiltonianSimulation, Circuit}}","page":"Tasks","title":"Braket.AwsQuantumTask","text":"AwsQuantumTask(device_arn::String, task_spec; kwargs...)\n\nLaunches an AwsQuantumTask based on task_spec on the device associated with device_arn.\n\ntask_spec must be one of:\n\nOpenQASMProgram\nBlackbirdProgram\nProblem\nProgram\nCircuit\nAhsProgram\nAnalogHamiltonianSimulation\n\nValid kwargs are:\n\ns3_destination_folder::Tuple{String, String}, with default value default_task_bucket().\nshots::Int - the number of shots to run, with default value 1000. Value must be between 0 and MAX_SHOTS for the specific device.\ndevice_params::Dict{String, Any} - device specific parameters. Currently only used for DWave devices and simulators.\ndisable_qubit_rewiring::Bool - whether to allow qubit rewiring in the compilation stage. Default is false.\npoll_timeout_seconds::Int - maximum number of seconds to wait while polling for results. Default: 432000\npoll_interval_seconds::Int - default number of seconds to wait between attempts while polling for results. Default: 1\ntags::Dict{String, String} - tags for the AwsQuantumTask\n\n\n\n\n\n","category":"method"},{"location":"tasks/#Braket.AwsQuantumTaskBatch","page":"Tasks","title":"Braket.AwsQuantumTaskBatch","text":"AwsQuantumTaskBatch\n\nStruct representing a batch of tasks run concurrently on an Amazon-managed device.\n\n\n\n\n\n","category":"type"},{"location":"tasks/#Braket.AwsQuantumTaskBatch-Tuple{String, Vector{<:Union{Braket.AbstractProgram, Circuit}}}","page":"Tasks","title":"Braket.AwsQuantumTaskBatch","text":"AwsQuantumTaskBatch(device_arn::String, task_specs::Vector{<:Union{AbstractProgram, Circuit}}; kwargs...) -> AwsQuantumTaskBatch\n\nLaunches a batch of concurrent tasks specified by task_specs on device_arn.\n\nValid kwargs are:\n\ns3_destination_folder::Tuple{String, String} - s3 bucket and prefix in which to store results. Default: default_task_bucket()\nshots::Int - the number of shots to run each task with. Default: 1000\npoll_timeout_seconds::Int - maximum number of seconds to wait while polling for results. Default: 432000\npoll_interval_seconds::Int - default number of seconds to wait between attempts while polling for results. Default: 1\n\n\n\n\n\n","category":"method"},{"location":"tasks/#Braket.results-Tuple{AwsQuantumTaskBatch}","page":"Tasks","title":"Braket.results","text":"results(b::AwsQuantumTaskBatch; kwargs)\n\nValid kwargs are:\n\nfail_unsuccessful::Bool - whether to throw an error if any tasks in the batch are unsuccessful after retries. Default: false\nmax_retries::Int - maximum number of times to retry a failed task. Default: 3\nuse_cached_value::Bool - whether to reuse previously downloaded results for tasks or download all results fresh. Default: true\n\nBlocks and waits while retrieving results for every task in b.\n\n\n\n\n\n","category":"method"},{"location":"noises/#Noises","page":"Noises","title":"Noises","text":"","category":"section"},{"location":"noises/","page":"Noises","title":"Noises","text":"Noise\nKraus\nBitFlip\nPhaseFlip\nPauliChannel\nAmplitudeDamping\nPhaseDamping\nDepolarizing\nTwoQubitDephasing\nTwoQubitDepolarizing\nGeneralizedAmplitudeDamping\nTwoQubitPauliChannel\nMultiQubitPauliChannel","category":"page"},{"location":"noises/#Braket.Noise","page":"Noises","title":"Braket.Noise","text":"Noise <: QuantumOperator\n\nAbstract type representing a quantum noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.Kraus","page":"Noises","title":"Braket.Kraus","text":"Kraus <: Noise\n\nKraus noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.BitFlip","page":"Noises","title":"Braket.BitFlip","text":"BitFlip <: Noise\n\nBitFlip noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.PhaseFlip","page":"Noises","title":"Braket.PhaseFlip","text":"PhaseFlip <: Noise\n\nPhaseFlip noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.PauliChannel","page":"Noises","title":"Braket.PauliChannel","text":"PauliChannel <: Noise\n\nPauliChannel noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.AmplitudeDamping","page":"Noises","title":"Braket.AmplitudeDamping","text":"AmplitudeDamping <: Noise\n\nAmplitudeDamping noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.PhaseDamping","page":"Noises","title":"Braket.PhaseDamping","text":"PhaseDamping <: Noise\n\nPhaseDamping noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.Depolarizing","page":"Noises","title":"Braket.Depolarizing","text":"Depolarizing <: Noise\n\nDepolarizing noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.TwoQubitDephasing","page":"Noises","title":"Braket.TwoQubitDephasing","text":"TwoQubitDephasing <: Noise\n\nTwoQubitDephasing noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.TwoQubitDepolarizing","page":"Noises","title":"Braket.TwoQubitDepolarizing","text":"TwoQubitDepolarizing <: Noise\n\nTwoQubitDepolarizing noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.GeneralizedAmplitudeDamping","page":"Noises","title":"Braket.GeneralizedAmplitudeDamping","text":"GeneralizedAmplitudeDamping <: Noise\n\nGeneralizedAmplitudeDamping noise operation.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.TwoQubitPauliChannel","page":"Noises","title":"Braket.TwoQubitPauliChannel","text":"TwoQubitPauliChannel <: Noise\n\nPauli channel noise operation on two qubits.\n\n\n\n\n\n","category":"type"},{"location":"noises/#Braket.MultiQubitPauliChannel","page":"Noises","title":"Braket.MultiQubitPauliChannel","text":"MultiQubitPauliChannel{N} <: Noise\n\nPauli channel noise operation on N qubits.\n\n\n\n\n\n","category":"type"},{"location":"device/#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"device/","page":"Devices","title":"Devices","text":"Device\nAwsDevice\nisavailable\nsearch_devices\nget_devices","category":"page"},{"location":"device/#Braket.Device","page":"Devices","title":"Braket.Device","text":"Device\n\nAbstract type representing a generic device which tasks (local or managed) may be run on.\n\n\n\n\n\n","category":"type"},{"location":"device/#Braket.AwsDevice","page":"Devices","title":"Braket.AwsDevice","text":"AwsDevice <: Device\n\nStruct representing an AWS managed device, either simulator or QPU.\n\n\n\n\n\n","category":"type"},{"location":"device/#Braket.isavailable","page":"Devices","title":"Braket.isavailable","text":"isavailable(d::AwsDevice) -> Bool\n\nIs device d currently available to run tasks on.\n\n\n\n\n\n","category":"function"},{"location":"device/#Braket.search_devices","page":"Devices","title":"Braket.search_devices","text":"search_devices(; kwargs...) -> Vector{Dict{String, Any}}\n\nSearch all AWS managed devices and filter the results using kwargs.\n\nValid kwargs are:\n\narns::Vector{String}: ARNs of devices to search for.\nnames::Vector{String}: Names of devices to search for.\ntypes::Vector{String}: Types of devices (e.g. QPU or simulator) to search for.\nstatuses::Vector{String}: Statuses of devices (e.g. \"ONLINE\" or \"OFFLINE\") to search for.\nprovider_names::Vector{String}: Providers of devices to search for.\n\n\n\n\n\n","category":"function"},{"location":"device/#Braket.get_devices","page":"Devices","title":"Braket.get_devices","text":"get_devices(; kwargs...) -> Vector{AwsDevice}\n\nReturn all AWS Devices satisfying the filters in kwargs. The devices have their properties populated and a region-appropriate AWSConfig attached.\n\nValid kwargs are:\n\narns::Vector{String}: ARNs of devices to search for.\nnames::Vector{String}: Names of devices to search for.\ntypes::Vector{String}: Types of devices (e.g. QPU or simulator) to search for.\nstatuses::Vector{String}: Statuses of devices (e.g. \"ONLINE\" or \"OFFLINE\") to search for.\nprovider_names::Vector{String}: Providers of devices to search for.\norder_by::String: property used to sort the devices. Default is \"name\".\n\n\n\n\n\n","category":"function"},{"location":"jobs/#Amazon-Braket-Hybrid-Jobs","page":"Amazon Braket Hybrid Jobs","title":"Amazon Braket Hybrid Jobs","text":"","category":"section"},{"location":"jobs/","page":"Amazon Braket Hybrid Jobs","title":"Amazon Braket Hybrid Jobs","text":"Amazon Braket Hybrid Jobs allow you to easily run hybrid classical-quantum workflows on AWS managed infrastructure by submitting your own scripts which run in a Docker container, either one provided by Amazon Braket or one that is made available to you through Amazon ECR. To learn more about Amazon Braket Hybrid Jobs, see the Developer Guide, and to learn how to provide your own Docker images, see the Bring Your Own Container (BYOC) guide.","category":"page"},{"location":"jobs/","page":"Amazon Braket Hybrid Jobs","title":"Amazon Braket Hybrid Jobs","text":"You can also run a LocalJob, which runs the container and your script on your compute hardware (your laptop, or an EC2 instance, for example), using PyBraket.jl. This can be useful for debugging and performance tuning purposes.","category":"page"},{"location":"jobs/","page":"Amazon Braket Hybrid Jobs","title":"Amazon Braket Hybrid Jobs","text":"AwsQuantumJob\nAwsQuantumJob(::String, ::String)\nlog_metric\nmetrics\nlogs\ndownload_result","category":"page"},{"location":"jobs/#Braket.AwsQuantumJob","page":"Amazon Braket Hybrid Jobs","title":"Braket.AwsQuantumJob","text":"AwsQuantumJob\n\nStruct representing an Amazon Braket Hybrid Job.\n\n\n\n\n\n","category":"type"},{"location":"jobs/#Braket.AwsQuantumJob-Tuple{String, String}","page":"Amazon Braket Hybrid Jobs","title":"Braket.AwsQuantumJob","text":"AwsQuantumJob(device::String, source_module::String; kwargs...)\n\nCreate and launch an AwsQuantumJob which will use device device (a managed simulator, a QPU, or an embedded simulator) and will run the code (either a single file, or a Julia package, or a Python module) located at source_module. The keyword arguments kwargs control the launch configuration of the job.\n\nKeyword Arguments\n\nentry_point::String - the function to run in source_module if source_module is a Python module/Julia package. Defaults to an empty string, in which case the behavior depends on the code language. In Python, the job will attempt to find a function called main in source_module and run it. In Julia, source_module will be loaded and run with Julia's include.\nimage_uri::String - the URI of the Docker image in ECR to run the Job on. Defaults to an empty string, in which case the base container is used.\njob_name::String - the name for the job, which will be displayed in the jobs console. The default is a combination of the container image name and the current time.\ncode_location::String - the S3 prefix URI to which code will be uploaded. The default is default_bucket()/jobs/<job_name>/script\nrole_arn::String - the IAM role ARN to use to run the job. The default is to use the default jobs role.\nwait_until_complete::Bool - whether to block until the job is complete, displaying log information as it arrives (true) or to run the job asynchronously (false, default).\nhyperparameters::Dict{String, Any} - hyperparameters to provide to the job which will be available from an environment variable when the job is run. See the Amazon Braket documentation for more.\ninput_data::Union{String, Dict} - information about the training/input data to provide to the job. A Dict should map channel names to local paths or S3 URIs. Contents found at any local paths encoded as Strings will be uploaded to S3 at s3://{default_bucket_name}/jobs/{job_name}/data/{channel_name}. If a local path or S3 URI is provided, it will be given a default channel name \"input\". The default is Dict().\ninstance_config::InstanceConfig - the instance configuration to use to run the job. See the Amazon Braket documentation for more information about available instance types. The default is InstanceConfig(\"ml.m5.large\", 1, 30).\ndistribution::String - specifies how the job should be distributed. If set to \"data_parallel\", the hyperparameters for the job will be set to use data parallelism features for PyTorch or TensorFlow.\nstopping_condition::StoppingCondition - the maximum length of time, in seconds, that a job can run before being forcefully stopped. The default is StoppingCondition(5 * 24 * 60 * 60).\noutput_data_config::OutputDataConfig - specifies the location for the output of the job. Any data stored here will be available to download_result and results. The default is OutputDataConfig(\"s3://{default_bucket_name}/jobs/{job_name}/data\").\ncopy_checkpoints_from_job::String - specifies the job ARN whose checkpoint is to be used in the current job. Specifying this value will copy over the checkpoint data from use_checkpoints_from_job's checkpoint_config S3 URI to the current job's checkpoint_config S3 URI, making it available at checkpoint_config.localPath during the job execution. The default is not to copy any checkpoints (an empty string).\ncheckpoint_config::CheckpointConfig - specifies the location where checkpoint data for this job is to be stored. The default is CheckpointConfig(\"/opt/jobs/checkpoints\", \"s3://{default_bucket_name}/jobs/{job_name}/checkpoints\").\ntags::Dict{String, String} - specifies the key-value pairs for tagging this job.\n\n\n\n\n\n","category":"method"},{"location":"jobs/#Braket.log_metric","page":"Amazon Braket Hybrid Jobs","title":"Braket.log_metric","text":"log_metric(metric_name::String, value::Union{Float64, Int}; timestamp=time(), iteration_number=nothing)\n\nWithin a job script, log a metric with name metric_name and value value which can later be fetched outside the job with metrics. A metric might be, for example, the loss of a training algorithm at each epoch, or similar.\n\n\n\n\n\n","category":"function"},{"location":"jobs/#Braket.metrics","page":"Amazon Braket Hybrid Jobs","title":"Braket.metrics","text":"metrics(j::AwsQuantumJob; metric_type=\"timestamp\", statistic=\"max\")\n\nFetches the metrics for job j. Metrics are generated by log_metric within the job script.\n\n\n\n\n\n","category":"function"},{"location":"jobs/#Braket.logs","page":"Amazon Braket Hybrid Jobs","title":"Braket.logs","text":"logs(j::AwsQuantumJob; wait::Bool=false, poll_interval_seconds::Int=5)\n\nFetches the logs of job j. If wait is true, blocks until j has entered a terminal state (\"COMPLETED\", \"FAILED\", or \"CANCELLED\"). Polls every poll_interval_seconds for new log data.\n\n\n\n\n\n","category":"function"},{"location":"jobs/#Braket.download_result","page":"Amazon Braket Hybrid Jobs","title":"Braket.download_result","text":"download_result(j::AwsQuantumJob; kwargs...)\n\nDownload and extract the results of job j. Valid kwargs are:\n\nextract_to::String - the local folder to extract the results to. Default is the current working directory.\npoll_timeout_seconds::Int - the maximum number of seconds to wait while polling for results. Default: 864000\npoll_interval_seconds::Int - how many seconds to wait between download attempts. Default: 5\n\n\n\n\n\n","category":"function"},{"location":"observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"observables/","page":"Observables","title":"Observables","text":"Braket.Observables.Observable\nBraket.Observables.X\nBraket.Observables.Y\nBraket.Observables.Z\nBraket.Observables.H\nBraket.Observables.I\nBraket.Observables.TensorProduct\nBraket.Observables.HermitianObservable","category":"page"},{"location":"observables/#Braket.Observables.Observable","page":"Observables","title":"Braket.Observables.Observable","text":"Observable <: Operator\n\nAbstract type representing an observable to be measured. All Observables have eigvals defined.\n\nSee also: H, I, X, Y, Z, TensorProduct, HermitianObservable.\n\n\n\n\n\n","category":"type"},{"location":"observables/#Braket.Observables.X","page":"Observables","title":"Braket.Observables.X","text":"Braket.Observables.X <: Observable\nBraket.Observables.X() -> Braket.Observables.X\n\nStruct representing a Braket.Observables.X observable in a measurement.\n\n\n\n\n\n","category":"type"},{"location":"observables/#Braket.Observables.Y","page":"Observables","title":"Braket.Observables.Y","text":"Braket.Observables.Y <: Observable\nBraket.Observables.Y() -> Braket.Observables.Y\n\nStruct representing a Braket.Observables.Y observable in a measurement.\n\n\n\n\n\n","category":"type"},{"location":"observables/#Braket.Observables.Z","page":"Observables","title":"Braket.Observables.Z","text":"Braket.Observables.Z <: Observable\nBraket.Observables.Z() -> Braket.Observables.Z\n\nStruct representing a Braket.Observables.Z observable in a measurement.\n\n\n\n\n\n","category":"type"},{"location":"observables/#Braket.Observables.H","page":"Observables","title":"Braket.Observables.H","text":"Braket.Observables.H <: Observable\nBraket.Observables.H() -> Braket.Observables.H\n\nStruct representing a Braket.Observables.H observable in a measurement.\n\n\n\n\n\n","category":"type"},{"location":"observables/#Braket.Observables.I","page":"Observables","title":"Braket.Observables.I","text":"Braket.Observables.I <: Observable\nBraket.Observables.I() -> Braket.Observables.I\n\nStruct representing a Braket.Observables.I observable in a measurement.\n\n\n\n\n\n","category":"type"},{"location":"observables/#Braket.Observables.TensorProduct","page":"Observables","title":"Braket.Observables.TensorProduct","text":"TensorProduct <: Observable\nTensorProduct(factors::Vector{<:Observable}) -> TensorProduct\nTensorProduct(factors::Vector{String}) -> TensorProduct\n\nStruct representing a tensor product of smaller observables.\n\nExamples\n\njulia> Braket.Observables.TensorProduct([\"x\", \"h\"])\nBraket.Observables.TensorProduct(Braket.Observables.Observable[Braket.Observables.X(), Braket.Observables.H()])\n\njulia> ho = Braket.Observables.HermitianObservable([0 1; 1 0]);\n\njulia> Braket.Observables.TensorProduct([ho, Braket.Observables.Z()])\nBraket.Observables.TensorProduct(Braket.Observables.Observable[Braket.Observables.HermitianObservable(Complex{Int64}[0 + 0im 1 + 0im; 1 + 0im 0 + 0im]), Braket.Observables.Z()])\n\n\n\n\n\n","category":"type"},{"location":"observables/#Braket.Observables.HermitianObservable","page":"Observables","title":"Braket.Observables.HermitianObservable","text":"HermitianObservable <: Observable\nHermitianObservable(matrix::Matrix) -> HermitianObservable\n\nStruct representing an observable of an arbitrary complex Hermitian matrix.\n\nExamples\n\njulia> ho = Braket.Observables.HermitianObservable([0 1; 1 0])\nBraket.Observables.HermitianObservable(Complex{Int64}[0 + 0im 1 + 0im; 1 + 0im 0 + 0im])\n\n\n\n\n\n","category":"type"},{"location":"compiler_directives/#Compiler-Directives","page":"Compiler Directives","title":"Compiler Directives","text":"","category":"section"},{"location":"compiler_directives/","page":"Compiler Directives","title":"Compiler Directives","text":"CompilerDirective\nStartVerbatimBox\nEndVerbatimBox","category":"page"},{"location":"compiler_directives/#Braket.CompilerDirective","page":"Compiler Directives","title":"Braket.CompilerDirective","text":"CompilerDirective <: Operator\n\nAbstract type representing a directive to a device-specific compiler.\n\n\n\n\n\n","category":"type"},{"location":"compiler_directives/#Braket.StartVerbatimBox","page":"Compiler Directives","title":"Braket.StartVerbatimBox","text":"StartVerbatimBox <: CompilerDirective\n\nDirective to begin a region of \"verbatim\" instructions, which will not be modified by any further compilation steps.\n\n\n\n\n\n","category":"type"},{"location":"compiler_directives/#Braket.EndVerbatimBox","page":"Compiler Directives","title":"Braket.EndVerbatimBox","text":"EndVerbatimBox <: CompilerDirective\n\nDirective to end a region of \"verbatim\" instructions, which will not be modified by any further compilation steps.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"Gate\nAngledGate\nH\nI\nX\nY\nZ\nPhaseShift\nRx\nRy\nRz\nV\nVi\nT\nTi\nS\nSi\nCNot\nCV\nCY\nCZ\nXX\nXY\nYY\nZZ\nECR\nCPhaseShift\nCPhaseShift00\nCPhaseShift01\nCPhaseShift10\nSwap\nPSwap\nISwap\nCSwap\nCCNot\nUnitary","category":"page"},{"location":"gates/#Braket.Gate","page":"Gates","title":"Braket.Gate","text":"Gate <: QuantumOperator\n\nAbstract type representing a quantum gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.AngledGate","page":"Gates","title":"Braket.AngledGate","text":"AngledGate <: Gate\n\nAbstract type representing a quantum gate with an angle parameter.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.H","page":"Gates","title":"Braket.H","text":"H <: Gate\nH() -> H\n\nH gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.I","page":"Gates","title":"Braket.I","text":"I <: Gate\nI() -> I\n\nI gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.X","page":"Gates","title":"Braket.X","text":"X <: Gate\nX() -> X\n\nX gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Y","page":"Gates","title":"Braket.Y","text":"Y <: Gate\nY() -> Y\n\nY gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Z","page":"Gates","title":"Braket.Z","text":"Z <: Gate\nZ() -> Z\n\nZ gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.PhaseShift","page":"Gates","title":"Braket.PhaseShift","text":"PhaseShift <: AngledGate\nPhaseShift(angle::Union{Float64, FreeParameter}) -> PhaseShift\n\nPhaseShift gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Rx","page":"Gates","title":"Braket.Rx","text":"Rx <: AngledGate\nRx(angle::Union{Float64, FreeParameter}) -> Rx\n\nRx gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Ry","page":"Gates","title":"Braket.Ry","text":"Ry <: AngledGate\nRy(angle::Union{Float64, FreeParameter}) -> Ry\n\nRy gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Rz","page":"Gates","title":"Braket.Rz","text":"Rz <: AngledGate\nRz(angle::Union{Float64, FreeParameter}) -> Rz\n\nRz gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.V","page":"Gates","title":"Braket.V","text":"V <: Gate\nV() -> V\n\nV gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Vi","page":"Gates","title":"Braket.Vi","text":"Vi <: Gate\nVi() -> Vi\n\nVi gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.T","page":"Gates","title":"Braket.T","text":"T <: Gate\nT() -> T\n\nT gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Ti","page":"Gates","title":"Braket.Ti","text":"Ti <: Gate\nTi() -> Ti\n\nTi gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.S","page":"Gates","title":"Braket.S","text":"S <: Gate\nS() -> S\n\nS gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Si","page":"Gates","title":"Braket.Si","text":"Si <: Gate\nSi() -> Si\n\nSi gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CNot","page":"Gates","title":"Braket.CNot","text":"CNot <: Gate\nCNot() -> CNot\n\nCNot gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CV","page":"Gates","title":"Braket.CV","text":"CV <: Gate\nCV() -> CV\n\nCV gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CY","page":"Gates","title":"Braket.CY","text":"CY <: Gate\nCY() -> CY\n\nCY gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CZ","page":"Gates","title":"Braket.CZ","text":"CZ <: Gate\nCZ() -> CZ\n\nCZ gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.XX","page":"Gates","title":"Braket.XX","text":"XX <: AngledGate\nXX(angle::Union{Float64, FreeParameter}) -> XX\n\nXX gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.XY","page":"Gates","title":"Braket.XY","text":"XY <: AngledGate\nXY(angle::Union{Float64, FreeParameter}) -> XY\n\nXY gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.YY","page":"Gates","title":"Braket.YY","text":"YY <: AngledGate\nYY(angle::Union{Float64, FreeParameter}) -> YY\n\nYY gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.ZZ","page":"Gates","title":"Braket.ZZ","text":"ZZ <: AngledGate\nZZ(angle::Union{Float64, FreeParameter}) -> ZZ\n\nZZ gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.ECR","page":"Gates","title":"Braket.ECR","text":"ECR <: Gate\nECR() -> ECR\n\nECR gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CPhaseShift","page":"Gates","title":"Braket.CPhaseShift","text":"CPhaseShift <: AngledGate\nCPhaseShift(angle::Union{Float64, FreeParameter}) -> CPhaseShift\n\nCPhaseShift gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CPhaseShift00","page":"Gates","title":"Braket.CPhaseShift00","text":"CPhaseShift00 <: AngledGate\nCPhaseShift00(angle::Union{Float64, FreeParameter}) -> CPhaseShift00\n\nCPhaseShift00 gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CPhaseShift01","page":"Gates","title":"Braket.CPhaseShift01","text":"CPhaseShift01 <: AngledGate\nCPhaseShift01(angle::Union{Float64, FreeParameter}) -> CPhaseShift01\n\nCPhaseShift01 gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CPhaseShift10","page":"Gates","title":"Braket.CPhaseShift10","text":"CPhaseShift10 <: AngledGate\nCPhaseShift10(angle::Union{Float64, FreeParameter}) -> CPhaseShift10\n\nCPhaseShift10 gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Swap","page":"Gates","title":"Braket.Swap","text":"Swap <: Gate\nSwap() -> Swap\n\nSwap gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.PSwap","page":"Gates","title":"Braket.PSwap","text":"PSwap <: AngledGate\nPSwap(angle::Union{Float64, FreeParameter}) -> PSwap\n\nPSwap gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.ISwap","page":"Gates","title":"Braket.ISwap","text":"ISwap <: Gate\nISwap() -> ISwap\n\nISwap gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CSwap","page":"Gates","title":"Braket.CSwap","text":"CSwap <: Gate\nCSwap() -> CSwap\n\nCSwap gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.CCNot","page":"Gates","title":"Braket.CCNot","text":"CCNot <: Gate\nCCNot() -> CCNot\n\nCCNot gate.\n\n\n\n\n\n","category":"type"},{"location":"gates/#Braket.Unitary","page":"Gates","title":"Braket.Unitary","text":"Unitary <: Gate\nUnitary(matrix::Matrix{ComplexF64}) -> Unitary\n\nArbitrary unitary gate.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Analog-Hamiltonian-Simulation","page":"Analog Hamiltonian Simulation","title":"Analog Hamiltonian Simulation","text":"","category":"section"},{"location":"ahs/","page":"Analog Hamiltonian Simulation","title":"Analog Hamiltonian Simulation","text":"AnalogHamiltonianSimulation\nAnalogHamiltonianSimulation(::Braket.AtomArrangement, ::Braket.Hamiltonian)\ndiscretize\nHamiltonian\nAtomArrangementItem\nAtomArrangementItem(::Tuple{Number, Number})\nTimeSeriesItem\nTimeSeries\nField\nShiftingField\nDrivingField\nir(::AnalogHamiltonianSimulation)","category":"page"},{"location":"ahs/#Braket.AnalogHamiltonianSimulation","page":"Analog Hamiltonian Simulation","title":"Braket.AnalogHamiltonianSimulation","text":"AnalogHamiltonianSimulation\n\nStruct representing instructions for an analog Hamiltonian simulation on a neutral atom device.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.AnalogHamiltonianSimulation-Tuple{Vector{AtomArrangementItem}, Hamiltonian}","page":"Analog Hamiltonian Simulation","title":"Braket.AnalogHamiltonianSimulation","text":"AnalogHamiltonianSimulation(register::AtomArrangement, hamiltonian) -> AnalogHamiltonianSimulation\n\nConstructs an AnalogHamiltonianSimulation on a specific atom arrangement register and with Hamiltonian terms hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"ahs/#Braket.discretize","page":"Analog Hamiltonian Simulation","title":"Braket.discretize","text":"discretize(ahs::AnalogHamiltonianSimulation, device::Device)\n\nCreates a new AnalogHamiltonianSimulation with all numerical values represented as Dec128 objects with fixed precision based on the capabilities of the device.\n\n\n\n\n\n","category":"function"},{"location":"ahs/#Braket.Hamiltonian","page":"Analog Hamiltonian Simulation","title":"Braket.Hamiltonian","text":"Hamiltonian\n\nAbstract type representing a term in the Hamiltonian to simulate.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.AtomArrangementItem","page":"Analog Hamiltonian Simulation","title":"Braket.AtomArrangementItem","text":"AtomArrangementItem\n\nRepresents a coordinate and filling in a setup for neutral atom simulation.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.AtomArrangementItem-Tuple{Tuple{Number, Number}}","page":"Analog Hamiltonian Simulation","title":"Braket.AtomArrangementItem","text":"AtomArrangementItem(coord::Tuple{Number, Number}, site_type::SiteType=filled)\n\nCreate a coordinate with filling site_type (either vacant or filled). Default filling is filled.\n\n\n\n\n\n","category":"method"},{"location":"ahs/#Braket.TimeSeriesItem","page":"Analog Hamiltonian Simulation","title":"Braket.TimeSeriesItem","text":"TimeSeriesItem\nTimeSeriesItem(time::Number, value::Number)\n\nStruct representing a value in a TimeSeries which occurs at time.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.TimeSeries","page":"Analog Hamiltonian Simulation","title":"Braket.TimeSeries","text":"TimeSeries\nTimeSeries()\n\nStruct representing a series of values in a neutral atom simulation.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.Field","page":"Analog Hamiltonian Simulation","title":"Braket.Field","text":"Field\nField(time_series::TimeSeries, [pattern::Pattern]) -> Field\n\nRepresentation of a generic field in a Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.ShiftingField","page":"Analog Hamiltonian Simulation","title":"Braket.ShiftingField","text":"ShiftingField <: Hamiltonian\nShiftingField(magnitude::Union{Field, TimeSeries}) -> ShiftingField\n\nRepresents a shifting field in a Hamiltonian which changes the energy of the Rydberg level in  an AnalogHamiltonianSimulation.\n\nH_sf(t) = - Delta(t) sum_k h_k left r_k rightrangleleftlangle r_k right\n\nWhere left r_k rightrangle is the Rydberg state of atom k, and h_k is the local pattern of unitless real numbers between 0 and 1.\n\nThe argument magnitude represents the global magnitude time series Delta(t), where time is in units of seconds and values are in units of radians / second.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.DrivingField","page":"Analog Hamiltonian Simulation","title":"Braket.DrivingField","text":"DrivingField <: Hamiltonian\nDrivingField(amplitude::Union{Field, TimeSeries}, phase::Union{Field, TimeSeries}, detuning::Union{Field, TimeSeries}) -> DrivingField\n\nRepresents a driving field in a Hamiltonian which coherently transfers atoms from the ground state to the Rydberg state in an AnalogHamiltonianSimulation.\n\nH_df(t) = frac12 Omega(t)exp(i phi(t)) sum_k left(  g_k ranglelangle r_k  + hcright) - Delta(t) sum_k r_k ranglelangle r_k \n\nWhere left g_k rightrangle is the ground state of atom k and left r_k rightrangle is the Rydberg state of atom k.\n\nArguments\n\namplitude represents the global amplitude Omega(t). The time is in units of seconds, and the value is in radians/second.\nphase represents the global phase phi(t). The time is in units of seconds, and the value is in radians/second.\ndetuning represents the global detuning Delta(t). The time is in units of seconds, and the value is in radians/second.\n\n\n\n\n\n","category":"type"},{"location":"ahs/#Braket.ir-Tuple{AnalogHamiltonianSimulation}","page":"Analog Hamiltonian Simulation","title":"Braket.ir","text":"ir(ahs::AnalogHamiltonianSimulation)\n\nGenerate IR from an AnalogHamiltonianSimulation which can be run on a neutral atom simulator or quantum device.\n\n\n\n\n\n","category":"method"},{"location":"circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"The Circuit struct is used to represent a gate-based quantum computation on qubits. Circuits can be built up iteratively by  applying them as functors to operations like so:","category":"page"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"julia> c = Circuit();\n\njulia> c(H, Qubit(0));\n\njulia> α = FreeParameter(:alpha);\n\njulia> c(Rx, Qubit(1), α);\n\njulia> c(Probability); # measures probability on all qubits","category":"page"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"This functor syntax can also be used to set the value of free parameters:","category":"page"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"julia> α = FreeParameter(:alpha);\n\njulia> θ = FreeParameter(:theta);\n\njulia> circ = Circuit([(H, 0), (Rx, 1, α), (Ry, 0, θ), (Probability,)]);\n\njulia> new_circ = circ(theta=2.0, alpha=1.0);\n\njulia> new_circ2 = circ(0.5); # sets the value of all FreeParameters to 0.5","category":"page"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"Circuit\nCircuit()\nCircuit(::Braket.Moments, ::Vector, ::Vector{Result}, ::Vector)\nCircuit(::AbstractVector)\nQubit\nQubitSet\nBraket.Operator\nBraket.QuantumOperator\nFreeParameter\ndepth\nqubits\nqubit_count","category":"page"},{"location":"circuits/#Braket.Circuit","page":"Circuits","title":"Braket.Circuit","text":"Circuit\n\nA representation of a quantum circuit that contains the instructions to be performed on a quantum device and the requested result types.\n\nSee:\n\nGates for all of the supported gates. \nNoises for all of the supported noise operations.\nCompiler Directives for all of the supported compiler directives.\nResults for all of the supported result types.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#Braket.Circuit-Tuple{}","page":"Circuits","title":"Braket.Circuit","text":"Circuit()\n\nConstruct an empty Circuit.\n\n\n\n\n\n","category":"method"},{"location":"circuits/#Braket.Circuit-Tuple{Braket.Moments, Vector, Vector{Result}, Vector}","page":"Circuits","title":"Braket.Circuit","text":"Circuit(m::Moments, ixs::Vector, rts::Vector{Result}, bri::Vector)\n\nConstruct a Circuit from a set of Moments, a vector of Instructions, a vector of Results, and a vector of basis rotation instructions.\n\n\n\n\n\n","category":"method"},{"location":"circuits/#Braket.Circuit-Tuple{AbstractVector}","page":"Circuits","title":"Braket.Circuit","text":"Circuit(v)\n\nConstruct a Circuit from a Vector-like v containing tuples of:\n\na Gate, Noise, or Result\nthe target qubits on which to apply the operator\nany construction arguments to the operator, e.g. an angle or Observable\n\nExamples\n\njulia> v = [(H, collect(0:10)), (Rx, 1, 0.2), (BitFlip, 0, 0.1)];\n\njulia> Circuit(v);\n\n\n\n\n\n","category":"method"},{"location":"circuits/#Braket.Qubit","page":"Circuits","title":"Braket.Qubit","text":"Qubit <: Integer\n\nWrapper struct representing a qubit.\n\nExamples\n\njulia> q = Qubit(0)\nQubit(0)\n\njulia> q == 0\ntrue\n\n\n\n\n\n","category":"type"},{"location":"circuits/#Braket.QubitSet","page":"Circuits","title":"Braket.QubitSet","text":"QubitSet\n\nAn OrderedSet-like object which represents the qubits a Circuit, Instruction, or Result acts on and their ordering. Elements may be Ints or Qubits.\n\nExamples\n\njulia> QubitSet(1, Qubit(0))\nQubitSet(1, Qubit(0))\n\njulia> QubitSet([2, 1])\nQubitSet(2, 1)\n\njulia> QubitSet()\nQubitSet()\n\njulia> QubitSet(QubitSet(5, 1))\nQubitSet(5, 1)\n\n\n\n\n\n","category":"type"},{"location":"circuits/#Braket.Operator","page":"Circuits","title":"Braket.Operator","text":"Operator\n\nAbstract type representing operations that can be applied to a Circuit. Subtypes include Gate, Noise, Observable, and CompilerDirective.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#Braket.QuantumOperator","page":"Circuits","title":"Braket.QuantumOperator","text":"QuantumOperator < Operator\n\nAbstract type representing quantum operations that can be applied to a Circuit. Subtypes include Gate and Noise.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#Braket.FreeParameter","page":"Circuits","title":"Braket.FreeParameter","text":"FreeParameter\nFreeParameter(name::Symbol) -> FreeParameter\n\nStruct representing a free parameter, which may be used to initialize to a parametrized Gate or Noise and then given a fixed value later by supplying a mapping to a Circuit.\n\n\n\n\n\n","category":"type"},{"location":"circuits/#Braket.depth","page":"Circuits","title":"Braket.depth","text":"depth(c::Circuit)\n\nReturns the number of moments in c. Also known as the \"parallel gate depth\".\n\nExamples\n\njulia> c = Circuit();\n\njulia> H(c, 0);\n\njulia> CNot(c, 0, 1);\n\njulia> depth(c)\n2\n\n\n\n\n\n","category":"function"},{"location":"circuits/#Braket.qubits","page":"Circuits","title":"Braket.qubits","text":"qubits(c::Circuit) -> QubitSet\n\nReturns a QubitSet containing all qubits that c is defined on.\n\nExamples\n\njulia> c = Circuit();\n\njulia> H(c, 0);\n\njulia> CNot(c, 0, 1);\n\njulia> qubits(c)\nQubitSet(0, 1)\n\n\n\n\n\n","category":"function"},{"location":"circuits/#Braket.qubit_count","page":"Circuits","title":"Braket.qubit_count","text":"qubit_count(c::Circuit) -> Int\n\nReturns the number of qubits that c is defined on.\n\nExamples\n\njulia> c = Circuit();\n\njulia> H(c, 0);\n\njulia> CNot(c, 0, 1);\n\njulia> qubit_count(c)\n2\n\n\n\n\n\n","category":"function"},{"location":"circuits/#Output-to-IR","page":"Circuits","title":"Output to IR","text":"","category":"section"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"Braket.jl provides several functions to transform a Circuit into IR which will be transmitted to Amazon managed QPUs or simulators. Currently, two output formats supported are OpenQASM, and JAQCD (an Amazon Braket native IR). You can control how IR translation is done through the global variable IRType and, if using OpenQASM, OpenQASMSerializationProperties.","category":"page"},{"location":"circuits/","page":"Circuits","title":"Circuits","text":"Braket.Instruction\nir\nIRType\nOpenQASMSerializationProperties","category":"page"},{"location":"circuits/#Braket.Instruction","page":"Circuits","title":"Braket.Instruction","text":"Instruction\nInstruction(o::Operator, target)\n\nRepresents a single operation applied to a Circuit. Contains an operator, which may be any subtype of Operator, and a target set of qubits to which the operator is applied.\n\nExamples\n\njulia> Instruction(H(), 1)\nBraket.Instruction(H(), QubitSet(1))\n\njulia> Instruction(CNot(), [1, Qubit(4)])\nBraket.Instruction(CNot(), QubitSet(1, Qubit(4)))\n\njulia> Instruction(StartVerbatimBox(), QubitSet())\nBraket.Instruction(StartVerbatimBox(), QubitSet())\n\n\n\n\n\n","category":"type"},{"location":"circuits/#Braket.ir","page":"Circuits","title":"Braket.ir","text":"ir(c::Circuit; serialization_properties::SerializationProperties=OpenQASMSerializationProperties())\n\nConvert a Circuit into IR that can be consumed by the Amazon Braket service, whether local simulators, on-demand simulators, or QPUs. The IR format to convert to by default is controlled by the global variable IRType, which can be modified. Currently :JAQCD and :OpenQASM are supported for Circuits. If writing to OpenQASM IR, optional OpenQASMSerializationProperties may be specified.\n\n\n\n\n\nir(ahs::AnalogHamiltonianSimulation)\n\nGenerate IR from an AnalogHamiltonianSimulation which can be run on a neutral atom simulator or quantum device.\n\n\n\n\n\n","category":"function"},{"location":"circuits/#Braket.IRType","page":"Circuits","title":"Braket.IRType","text":"IRType\n\nA Ref{Symbol} which records which IR output format to use by default. Currently, two formats are supported:\n\n:JAQCD, the Amazon Braket IR\n:OpenQASM, the OpenQASM3 representation\n\nBy default, IRType is initialized to use :JAQCD, although this may change in the future. The current default value can be checked by calling IRType[]. To change the default IR format, set IRType[].\n\nExamples\n\njulia> IRType[]\n:JAQCD\n\njulia> IRType[] = :OpenQASM;\n\njulia> IRType[]\n:OpenQASM\n\njulia> IRType[] = :JAQCD;\n\n\n\n\n\n","category":"constant"},{"location":"circuits/#Braket.OpenQASMSerializationProperties","page":"Circuits","title":"Braket.OpenQASMSerializationProperties","text":"OpenQASMSerializationProperties(qubit_reference_type=VIRTUAL)\n\nContains information about how to serialize qubits when outputting to OpenQASM IR. The qubit_reference_type argument may be one of VIRTUAL or PHYSICAL.\n\n\n\n\n\n","category":"type"},{"location":"#Braket.jl-Documentation","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"","category":"section"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"Braket.jl is not an officially supported AWS product.","category":"page"},{"location":"#Introduction","page":"Braket.jl Documentation","title":"Introduction","text":"","category":"section"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"This is the documentation for the Braket.jl package, a Julia reimplementation of the Amazon Braket SDK. Please also refer to the documentation of that package and the official Amazon Braket documentation - if your question isn't answered here, it may be at one of those two locations.","category":"page"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"This is experimental software, and support may be discontinued in the future. For a fully supported SDK, please use the Python SDK. We may change, remove, or deprecate parts of the API when making new releases. Please review the CHANGELOG for information about changes in each release. ","category":"page"},{"location":"#What-is-Amazon-Braket?","page":"Braket.jl Documentation","title":"What is Amazon Braket?","text":"","category":"section"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"Amazon Braket is a fully-managed AWS service that helps researchers, scientists, and developers get started with quantum computing. Quantum computing has the potential to solve computational problems that are beyond the reach of classical computers because it harnesses the laws of quantum mechanics to process information in new ways.","category":"page"},{"location":"#Is-Braket.jl-the-same-thing-as-Amazon-Braket?","page":"Braket.jl Documentation","title":"Is Braket.jl the same thing as Amazon Braket?","text":"","category":"section"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"No. Braket.jl is a \"software development kit\" (SDK) written in Julia which allows you to interact with the Amazon Braket service in a similar way to the Python SDK. You can build gate-based quantum circuits, analog Hamiltonian simulations, and other constructs and then submit them to the Amazon Braket service to run on AWS managed devices/infrastructure or run them locally. ","category":"page"},{"location":"#Quick-start","page":"Braket.jl Documentation","title":"Quick start","text":"","category":"section"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"In order to use most features of Amazon Braket, you will not need a Python installation or to install the Python SDK or any of its dependencies. There are some exceptions - if you want to run a LocalJob or run a task on one of the Braket local simulators you will need to use the Python interoperability package PyBraket.jl, which comes with Braket.jl as a sub-packge in the same repo. Refer to the PyBraket.jl README for more information.","category":"page"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"If you want to run tasks or Amazon Braket Hybrid Jobs on AWS managed devices, you will need to have an AWS account and to onboard to Braket.","category":"page"},{"location":"#Examples-and-tutorials","page":"Braket.jl Documentation","title":"Examples and tutorials","text":"","category":"section"},{"location":"","page":"Braket.jl Documentation","title":"Braket.jl Documentation","text":"Many examples of quantum workflows are available at the Amazon Braket Examples repo. These tutorials cover most aspects of the service and are written in Python, but a conversion to Julia is usually straightforward. There are also examples provided in the examples folder of this repository.","category":"page"},{"location":"aws/#AWS","page":"AWS","title":"AWS","text":"","category":"section"},{"location":"aws/","page":"AWS","title":"AWS","text":"This section describes functions which are generic over several types which represent various workflows running on AWS - whether jobs, tasks, or something else.","category":"page"},{"location":"aws/","page":"AWS","title":"AWS","text":"arn\nmetadata\nstate\ncancel\nresult","category":"page"},{"location":"aws/#Braket.arn","page":"AWS","title":"Braket.arn","text":"arn(j::AwsQuantumJob)\n\nReturns the ARN identifying the job j. This ARN can be used to reconstruct the job after the session that launched it has exited.\n\n\n\n\n\narn(t::AwsQuantumTask) -> String\n\nReturns the ARN identifying the task t. This ARN can be used to  reconstruct the task after the session that launched it has exited.\n\n\n\n\n\n","category":"function"},{"location":"aws/#Braket.metadata","page":"AWS","title":"Braket.metadata","text":"metadata(j::AwsQuantumJob, ::Val{true})\nmetadata(j::AwsQuantumJob, ::Val{false})\nmetadata(j::AwsQuantumJob)\n\nFetch metadata for job j. If the second argument is ::Val{true}, use previously cached metadata, if available, otherwise fetch it from the Braket service. If the second argument is ::Val{false} (default), do not use previously cached metadata, and fetch fresh metadata from the Braket service.\n\n\n\n\n\nmetadata(t::AwsQuantumTask, ::Val{false})\nmetadata(t::AwsQuantumTask, ::Val{true})\n\nFetch metadata for task t. If the second argument is ::Val{true}, use previously cached metadata, if available, otherwise fetch it from the Braket service. If the second argument is ::Val{false}, do not use previously cached metadata, and fetch fresh metadata from the Braket service.\n\n\n\n\n\n","category":"function"},{"location":"aws/#Braket.state","page":"AWS","title":"Braket.state","text":"state(j::AwsQuantumJob, ::Val{true})\nstate(j::AwsQuantumJob, ::Val{false})\nstate(j::AwsQuantumJob)\n\nFetch the state for job j. Possible states are \"CANCELLED\", \"FAILED\", \"COMPLETED\", \"QUEUED\", and \"RUNNING\". If the second argument is ::Val{true}, use previously cached metadata, if available, otherwise fetch it from the Braket service. If the second argument is ::Val{false} (default), do not use previously cached metadata, and fetch fresh metadata from the Braket service.\n\n\n\n\n\nstate(t::AwsQuantumTask, ::Val{false}) -> String\nstate(t::AwsQuantumTask, ::Val{true}) -> String\nstate(t::AwsQuantumTask) -> String\n\nFetch the state for task t. Possible states are \"CANCELLED\", \"FAILED\", \"COMPLETED\", \"QUEUED\", and \"RUNNING\". If the second argument is ::Val{true}, use previously cached metadata, if available, otherwise fetch it from the Braket service. If the second argument is ::Val{false} (default), do not use previously cached metadata, and fetch fresh metadata from the Braket service.\n\n\n\n\n\n","category":"function"},{"location":"aws/#Braket.cancel","page":"AWS","title":"Braket.cancel","text":"cancel(j::AwsQuantumJob)\n\nCancels the job j.\n\n\n\n\n\ncancel(t::AwsQuantumTask)\n\nCancels the task t.\n\n\n\n\n\n","category":"function"},{"location":"aws/#Braket.result","page":"AWS","title":"Braket.result","text":"result(j::AwsQuantumJob; kwargs...)\n\nDownload, extract, and deserialize the results of job j. Valid kwargs are:\n\npoll_timeout_seconds::Int - the maximum number of seconds to wait while polling for results. Default: 864000\npoll_interval_seconds::Int - how many seconds to wait between download attempts. Default: 5\n\n\n\n\n\nresult(t::AwsQuantumTask)\n\nFetches the result of task t, if available. Blocks until a result is available, in which case the result is returned, or the task enters a terminal state without a result (\"FAILED\" or \"CANCELLED\") or exceeds its its polling timeout (set at task creation), in which case nothing is returned.\n\n\n\n\n\n","category":"function"}]
}
